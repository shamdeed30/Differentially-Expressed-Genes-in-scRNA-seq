---
title: "Differentially Expressed Genes in High Glucose Treated Cells"
output: html_document
date: "2024-10-06"
---

### Load packages

```{r, message=FALSE}
library(Seurat)
library(ggplot2)
library(patchwork)
library(knitr)
library(dplyr)
```

### Load data

```{r, warning=FALSE}
control_data <- Read10X(data.dir = 'GSE276251_RAW/control/')
control <- CreateSeuratObject(counts = control_data, project = 'control', min.cells = 3, min.features = 200)

high_glucose_data <- Read10X(data.dir = 'GSE276251_RAW/high_glucose/')
high_glucose <- CreateSeuratObject(counts = high_glucose_data, project = 'high_glucose', min.cells = 3, min.features = 200)

```

### Combine CONTROL and HIGH GLUCOSE objects

```{r}
# combine CONTROL and HIGH GLUCOSE
combined <- merge(control, y = high_glucose, add.cell.ids = c("Control", "HighGlucose"))
head(combined@meta.data, 5)
```

# 1. Filter out low-quality cells

```{r}
# calculate mitochondrial percentages
combined[["percent.mt"]] <- PercentageFeatureSet(combined, pattern = "^mt-")
head(combined@meta.data, 5)
```

```{r, warning=FALSE, fig.width=12, fig.height=8}
# create violin plots
VlnPlot(combined, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
```

```{r, fig.width=12, fig.height=8}
# plot mitochondria percentage and feature counts against RNA counts
plot1 <- FeatureScatter(combined, feature1 = "nCount_RNA", feature2 = "percent.mt") + scale_y_continuous(breaks = seq(0, 100, by = 5)) + geom_point(alpha = 0.05)

plot2 <- FeatureScatter(combined, feature1 = "nCount_RNA", feature2 = "nFeature_RNA") + scale_y_continuous(breaks = seq(0, 8500, by = 500)) + geom_point(alpha = 0.05)

plot1 + plot2
```

### Filtration: (200 \> nFeature_RNA \> 7000) and (percent.mt \< 10)

Discussion: Based on the plots, I decided to choose these filtration parameters. I applied the same filtration on CONTROL and HIGH GLUCOSE for comparability. High percentage of mitochonrial percentage indicate that the cell is stressed/dying. Therefore, filtering high mitochondrial percentage will ensure that DEGs observed would be due to biological variation rather than data variability.

```{r}
# filter meta.data based on the conditions
combined <- subset(combined, subset = nFeature_RNA > 200 & nFeature_RNA < 7000 & percent.mt < 10)
```

# 2. Clustering Analysis

### Discussion:

SCTransform, as mentioned in the paper by Choudhary et al., replaces the need to run NormalizeData, FindVariableFeatures, and ScaleData separately. It also tackles with confounding due to mitochondrial percentage during normalizatoin. However, I decided not to use SCTransform.

```{r, message=FALSE}
# normalize data to reduce the effect of highly expressed genes
combined <- NormalizeData(combined, normalization.method = "LogNormalize", scale.factor = 10000)
```

```{r, message=FALSE}
# calculate a subset of features that exhibit high cell-to-cell variation
combined <- FindVariableFeatures(combined, selection.method = "vst", nfeatures = 2000)
```

```{r, message=FALSE}
# scale the data for PCA
# scaling performs linear transformation to get mean of 0 and variation of 1
all_genes_combined <- rownames(combined)
combined <- ScaleData(combined, features = all_genes_combined)
```

```{r, message=FALSE}
# perform PCA
combined <- RunPCA(combined, features = VariableFeatures(object = combined))
```

```{r}
# analyze elbow plot to find optimal PC dimension
ElbowPlot(combined, ndims=50) + ggtitle('Elbowplot of PC Dimension vs. Std Dev')
```

### Discussion:

I chose 20 as the elbow point. Although 10 PCs is usually picked, but based on this elbowplot I chose 20 PCs, as up to this point we can expect to gain significant information.

Additionally, I used the clustering resolution at 0.4, which is crucial for accurate interpretation.

```{r, message=FALSE, warning=FALSE}
# perform clustering
uninteg <- FindNeighbors(combined, dims = 1:20, reduction = "pca")
uninteg <- FindClusters(uninteg, resolution = .4, cluster.name = "unintegrated_clusters")
```

```{r, warning=FALSE}
# perform UMAP for visualization
uninteg <- RunUMAP(uninteg, dims = 1:20, reduction = "pca", reduction.name = "umap.unintegrated")
```

```{r}
# visulize clusters
DimPlot(uninteg, reduction = "umap.unintegrated", label = TRUE) + ggtitle('Dimplot of clusters')
```

# 3. Integrate CONTROL and HIGH GLUCOSE datasets

```{r}
# integrate the splits on CONTROL and HIGH GLUCOSE
integ <- IntegrateLayers(object = combined, method = CCAIntegration, orig.reduction = "pca", new.reduction = "integrated.cca",
    verbose = FALSE)
```

```{r}
# join the integrated layers
integ[["RNA"]] <- JoinLayers(integ[["RNA"]])
```

```{r, message=FALSE, warning=FALSE}
# perform clustering
integ <- FindNeighbors(integ, reduction = "integrated.cca", dims = 1:20)
integ <- FindClusters(integ, resolution = .4)
```

```{r}
# perform UMAP for visualization
integ <- RunUMAP(integ, dims = 1:20, reduction = "integrated.cca")
```

```{r}
# visualization
DimPlot(integ, reduction = "umap", label = TRUE) + ggtitle('Dimplot of clusters after integration')
```

# 4. Identify differentially expressed genes (DEGs)

### Discussion:

I decided not to use pseudobulk approach using AggregateExpression. Rather I created my own object to contain all the DEGs for all exhaustive cluster-condition pairs.

Furthermore, I kept the clusters as (0,1,2,3,..) instead of naming them as mentioned.

```{r}
# create a new column that combines cluster and group (control/high glucose) information
integ$cond_cluster <- paste(Idents(integ), ifelse(integ$orig.ident == "control", "Con", "HG"), sep = '_')
Idents(integ) <- integ$cond_cluster
```

```{r, fig.width=14, fig.height=8}
# visualize CONTROL and HIGH GLUCOSE separately
DimPlot(integ, reduction='umap', label = TRUE, split.by = 'orig.ident') + ggtitle('Dimplot of clusters by control(Con)  and high glucose(HG) group')
```

```{r}
# check the indentifiers
table(Idents(integ))
```

```{r}
# List for contating DEGs for each cluster groups
top_DEGs_by_cluster_condition <- list()
```

```{r}
# get unique clusters and conditions
clusters <- unique(integ$seurat_clusters)
conditions <- unique(integ$orig.ident)
```

### Discussion:

I only did control\_# vs high_glucose\_# since the absolute avg_log2FC values are the same if they are flipped i.e. if the control and high_glucose groups are flipped in FindMarkers, the signs of avg_log2FC values get flipped. Therefore, I decided not to include both directions for simplicity.

In my analysis I am calculating the 10 most differentially expressed genes (DEGs) regardless of direction (positive or negative). The values are sorted based on the absolute values of avg_log2FC, however I am keeping their signed value for relaying the mutual direction.

```{r}
# calculate DEGs for cluster-condition pairs
for (cluster in clusters) {
      # create identifiers for the cluster groups
      ident.1 <- paste(cluster, 'Con', sep = "_")
      ident.2 <- paste(cluster, 'HG', sep = "_")

      # find markers between the two conditions in the same cluster
      markers <- FindMarkers(integ, ident.1 = ident.1, ident.2 = ident.2)
      # get top genes based on highest absolute avg_log2FC
      top_genes <- head(markers[order(-abs(markers$avg_log2FC)), ], n = 10) 
      top_DEGs_by_cluster_condition[[paste("Cluster", cluster, "CONTROL", "and GLUCOSE")]] <- top_genes
}

```

### Print highest 10 DEGs for each cluster

```{r}
# print the top 10 DEGs for clusters (0,1,2,3,...)
for (name in names(top_DEGs_by_cluster_condition)) {
  # print the table
  knitr::kable(top_DEGs_by_cluster_condition[[name]], caption = name) %>%
    print()
  
  cat("\n\n")
}
```
